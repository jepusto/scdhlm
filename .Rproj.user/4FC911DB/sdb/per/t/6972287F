{
    "contents" : "##------------------------------------------------------------------------------\n## Create AR(1) correlation and inverse correlation matrices\n##------------------------------------------------------------------------------\n\nAR1_corr <- function(phi, times) phi^as.matrix(dist(times))\n\n\nAR1_corr_block <- function(phi, block, times=NULL) {\n  if (is.null(times)) times <- lapply(table(block), seq, from=1)\n  lapply(times, AR1_corr, phi=phi)\n}\n\n\nAR1_corr_inv <- function(phi, n) \n  diag((rep(1,n) + c(0,rep(phi^2,n-2),0))/(1 - phi^2)) + \n      rbind(cbind(rep(0,n-1), diag(rep(-phi/(1 - phi^2),n-1))), rep(0,n)) + \n      rbind(rep(0,n), cbind(diag(rep(-phi/(1 - phi^2),n-1)),rep(0,n-1)))\n\n\n\n##------------------------------------------------------------------------------\n## Create lme covariance and inverse covariance matrices\n##------------------------------------------------------------------------------\n\n# create covariance matrix from Tau parameters \n\nTau_matrix <- function(Tau_coef) {\n  q <- (sqrt(1 + 8 * length(Tau_coef)) - 1) / 2\n  Tau_mat <- matrix(NA,q,q)\n  Tau_mat[upper.tri(Tau_mat, diag=TRUE)] <- Tau_coef\n  Tau_mat[lower.tri(Tau_mat)] <- t(Tau_mat)[lower.tri(Tau_mat)]\n  return(Tau_mat)\n}\n\n\n# create block-diagonal covariance matrix with AR(1) level-1 error\n\nlmeAR1_cov_block <- function(block, Z_design, theta, times = NULL) {\n  Tau_mat <- Tau_matrix(theta$Tau)\n  ZTauZ <- by(Z_design, block, function(z) {\n            z_mat <- as.matrix(z)\n            z_mat %*% Tau_mat %*% t(z_mat)})\n  AR1_mat <- AR1_corr_block(phi=theta$phi, block=block, times=times)\n  mapply(function(a,b) a + theta$sigma_sq * b, ZTauZ, AR1_mat, SIMPLIFY = FALSE)\n}\n\n\n# create inverse covariance matrix for a single block\n\n# Note: This function assumes that either \n# a) the Tau argument is passed as the eigen-decomposition of Tau\n# including an indicator vector for which dimensions to use or \n# b) Tau is an invertible matrix.\n# Option (a) must be used if Tau is of less than full rank.\n# what about 1-dimensional Tau with tau_0^2 = 0?\n\nlmeAR1_cov_inv  <- function(Z_design, sigma_sq, phi, Tau, times=NULL) {\n  if (is.null(times)) {\n    n <- ifelse(is.vector(Z_design), length(Z_design), dim(Z_design)[1])\n    A_inv <- AR1_corr_inv(phi, n) / sigma_sq\n  } else {\n    A_inv <- solve(AR1_corr(phi, times)) / sigma_sq\n  }\n\n  if (class(Tau)==\"list\") {\n    if (sum(Tau$use) == 0) return(A_inv) else {\n      # use eigen-decomposition of Tau if available\n      Z_mat <- as.matrix(Z_design) %*% Tau$vectors[,Tau$use]\n      Tau_inv <- diag(1/Tau$values[Tau$use], nrow=sum(Tau$use))\n    }\n  } else {\n    # otherwise assume that Tau is invertible\n    Z_mat <- as.matrix(Z_design)\n    Tau_inv <- chol2inv(chol(Tau))\n  }\n  A_inv_Z <- A_inv %*% Z_mat\n  A_inv - A_inv_Z %*% chol2inv(chol(Tau_inv + t(Z_mat) %*% A_inv_Z)) %*% t(A_inv_Z)  \n}\n\n\n# create block-diagonal inverse covariance matrix\n\nlmeAR1_cov_block_inv <- function(block, Z_design, theta, times=NULL) {\n  Tau_eigen <- eigen(Tau_matrix(theta$Tau), symmetric=TRUE)\n  Tau_eigen$use <- round(Tau_eigen$values,14) > 0\n  if (is.null(times)) {\n    by(Z_design, block, lmeAR1_cov_inv, sigma_sq=theta$sigma_sq, phi=theta$phi, Tau=Tau_eigen)\n  } else {\n    Z_list <- by(Z_design, block, function(x) x)\n    mapply(lmeAR1_cov_inv, Z_design = Z_list, times = times, \n           MoreArgs = list(sigma_sq=theta$sigma_sq, phi=theta$phi, Tau=Tau_eigen))\n  }\n}\n\n\n##------------------------------------------------------------------------------\n## create Q matrix\n##------------------------------------------------------------------------------\n\nQ_matrix <- function(block, X_design, Z_design, theta, times=NULL) {\n  V_inv <- lmeAR1_cov_block_inv(block=block, Z_design=Z_design, theta=theta, times=times)\n  Vinv_X <- prod_blockmatrix(V_inv, X_design, block = block)\n  VinvX_XVXinv_XVinv <- Vinv_X %*% chol2inv(chol(t(X_design) %*% Vinv_X)) %*% t(Vinv_X)\n  block_minus_matrix(V_inv, VinvX_XVXinv_XVinv, block)\n}\n\n\n##------------------------------------------------------------------------------\n## Create first derivative matrices\n##------------------------------------------------------------------------------\n\ndV_dsigmasq <- function(block, times, phi)\n  AR1_corr_block(phi=phi, block=block, times=times)\n#dV_dsigmasq(block=rep(1:3, each = 4), times=NULL, phi=0.5)\n\ndV_dphi <- function(block, times, phi, sigma_sq) {\n  if (is.null(times)) times <- lapply(table(block), seq, from=1)\n  time_diff <- lapply(times, function(x) as.matrix(dist(x)))\n  lapply(time_diff, function(x) sigma_sq * x * phi^pmax(0, x - 1))\n}\n\ndV_dTau_index <- function(block, Z_design, tau_index)\n  by(Z_design, block, function(Z) \n    as.matrix(Z)[,tau_index, drop=FALSE] %*% t(Z)[rev(tau_index),,drop=FALSE])\n\ndV_dTau_unstruct <- function(block, Z_design) {\n  Tau_q <- dim(Z_design)[2]\n  tau_index <- cbind(unlist(sapply(1:Tau_q, function(x) seq(1,x))), \n                     unlist(sapply(1:Tau_q, function(x) rep(x,x))))\n  apply(tau_index, 1, function(t) dV_dTau_index(block, Z_design, tau_index=unique(t)))\n}\n\n##------------------------------------------------------------------------------\n## extract variance components\n##------------------------------------------------------------------------------\n\nextract_varcomp <- function(m_fit) {\n  sigma_sq <- m_fit$sigma^2                                         # sigma^2\n  phi <- as.double(coef(m_fit$modelStruct$corStruct, FALSE))        # phi\n  Tau_coef <- coef(m_fit$modelStruct$reStruct, FALSE) * sigma_sq    # unique coefficients in Tau\n  \n  varcomp <- list(sigma_sq=sigma_sq, phi=phi, Tau = Tau_coef)\n  class(varcomp) <- \"varcomp\"\n  return(varcomp)\n}\n\n\n##------------------------------------------------------------------------------\n## Expected Information Matrix \n##------------------------------------------------------------------------------\n\nInfo_Expected <- function(theta, X_design, Z_design, block, times=NULL) {\n  \n  Q_mat <- Q_matrix(block, X_design, Z_design, theta, times=times) \n  \n  # create N * N * r array with QdV entries\n  r <- length(unlist(theta))\n  QdV <- array(NA, dim = c(dim(Q_mat),r))\n  QdV[,,1] <- prod_matrixblock(Q_mat, dV_dsigmasq(block=block, times=times, phi=theta$phi), block=block)\n  QdV[,,2] <- prod_matrixblock(Q_mat, dV_dphi(block=block, times=times, phi=theta$phi, sigma_sq=theta$sigma_sq), block=block)\n  QdV[,,-2:-1] <- unlist(lapply(dV_dTau_unstruct(block, Z_design), prod_matrixblock, A=Q_mat, block=block))\n  \n  # calculate I_E\n  I_E <- matrix(NA, r, r)\n  for (i in 1:r)\n    for (j in 1:i)\n      I_E[i,j] <- product_trace(QdV[,,i], QdV[,,j]) / 2\n  I_E[upper.tri(I_E)] <- t(I_E)[upper.tri(I_E)]\n  \n  return(I_E)\n}\n\n#' @title Calculate expected information matrix\n#' \n#' @description Calculates the expected information matrix from a fitted linear mixed effects\n#' model with AR(1) correlation structure in the level-1 errors.\n#' \n#' @param m_fit Fitted model of class lme, with AR(1) correlation structure at level 1.\n#' \n#' @export \n#' \n#' @return Expected Information matrix corresponding to variance components of \\code{m_fit}.\n\nInfo_Expected_lmeAR1 <- function(m_fit) {\n  theta <- extract_varcomp(m_fit)\n  X_design <- model.matrix(m_fit, data = m_fit$data)\n  Z_design <- model.matrix(m_fit$modelStruct$reStruct, data = m_fit$data)\n  block <- nlme::getGroups(m_fit)\n  times <- attr(m_fit$modelStruct$corStruct, \"covariate\")\n  Info_Expected(theta=theta, X_design=X_design, Z_design=Z_design, block=block, times=times)\n}\n\n\n\n## estimate adjusted REML effect size (with associated estimates) for multiple baseline design ####\n\n#' @title Calculates adjusted REML effect size\n#' \n#' @description Estimates a design-comparable standardized mean difference effect size based on data \n#' from a multiple baseline design, using adjusted REML method as described in Pustejovsky, Hedges, \n#' & Shadish (2013). Note that the data must contain one row per measurement occasion per case.\n#' \n#' @param m_fit Fitted model of class lme, with AR(1) correlation structure at level 1.\n#' @param p_const Vector of constants for calculating numerator of effect size. \n#' Must be the same length as fixed effects in \\code{m_fit}.\n#' @param r_const Vector of constants for calculating denominator of effect size. \n#' Must be the same length as the number of variance component parameters in \\code{m_fit}.\n#' @param X_design (Optional) Design matrix for fixed effects. Will be extracted from \\code{m_fit} if not specified.\n#' @param Z_design (Optional) Design matrix for random effects. Will be extracted from \\code{m_fit} if not specified.\n#' @param block (Optional) Factor variable describing the blocking structure. Will be extracted from \\code{m_fit} if not specified.\n#' @param times (Optional) list of times used to describe AR(1) structure. Will be extracted from \\code{m_fit} if not specified.\n#' \n#' @export \n#' \n#' @return A list with the following components\n#' \\tabular{ll}{\n#' \\code{p_beta} \\tab Numerator of effect size \\cr\n#' \\code{r_theta} \\tab Squared denominator of effect size \\cr\n#' \\code{delta_AB} \\tab Unadjusted (REML) effect size estimate \\cr\n#' \\code{nu} \\tab Estimated denominator degrees of freedom \\cr\n#' \\code{g_AB} \\tab Corrected effect size estimate \\cr\n#' \\code{V_g_AB} \\tab Approximate variance estimate \\cr\n#' \\code{cnvg_warn} \\tab Indicator that model did not converge \\cr\n#' \\code{sigma_sq} \\tab Estimated level-1 variance \\cr\n#' \\code{phi} \\tab Estimated autocorrelation \\cr\n#' \\code{Tau} \\tab Vector of level-2 variance components \\cr\n#' \\code{I_E_inv} \\tab Expected information matrix \\cr\n#' }\n#' \n#' @references Pustejovsky, J. E., Hedges, L. V., & Shadish, W. R. (2013). \n#' Design-comparable effect sizes in multiple baseline designs: A general approach\n#' to modeling and estimation.\n#' \n\ng_REML <- function(m_fit, p_const, r_const, \n                   X_design = model.matrix(m_fit, data = m_fit$data), \n                   Z_design = model.matrix(m_fit$modelStruct$reStruct, data = m_fit$data), \n                   block = nlme::getGroups(m_fit),\n                   times = attr(m_fit$modelStruct$corStruct, \"covariate\")) {\n\n  # basic model estimates\n  p_beta <- sum(nlme::fixed.effects(m_fit) * p_const)               # p'Beta\n  theta <- extract_varcomp(m_fit)                                   # full theta vector\n  r_theta <- sum(unlist(theta) * r_const)                           # r'theta\n  delta_AB <- p_beta / sqrt(r_theta)                                # delta_AB              \n  kappa_sq <- (t(p_const) %*% vcov(m_fit) %*% p_const) / r_theta    # kappa^2\n  cnvg_warn <- !is.null(attr(m_fit,\"warning\"))                      # indicator that RML estimation has not converged\n      \n  # calculate inverse expected information\n  I_E <- Info_Expected(theta=theta, X_design=X_design, Z_design=Z_design, block=block, times=times)\n  I_E_inv <- chol2inv(chol(I_E))\n  \n\n  nu <- 2 * r_theta^2 / (t(r_const) %*% I_E_inv %*% r_const)\n  g_AB <- J(nu) * delta_AB\n  nu_trunc <- max(nu, 2.001)\n  V_g_AB <- J(nu)^2 * (nu_trunc * kappa_sq / (nu_trunc - 2) + g_AB^2 * (nu_trunc / (nu_trunc - 2) - 1 / J(nu_trunc)^2))\n  \n  return(c(list(p_beta=p_beta, r_theta=r_theta, delta_AB=delta_AB, nu=nu, \n                 g_AB=g_AB, V_g_AB=V_g_AB, cnvg_warn=cnvg_warn), theta, list(I_E_inv=I_E_inv)))\n}\n\n\n",
    "created" : 1386778719380.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "668498899",
    "id" : "6972287F",
    "lastKnownWriteTime" : 1386970606,
    "path" : "~/My Box Files/Single-case research/scdhlm/R/REML-ES-functions.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}