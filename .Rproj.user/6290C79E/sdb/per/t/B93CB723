{
    "contents" : "## matrix trace function ####\n\nproduct_trace <- function(A,B) sum(as.vector(t(A)) * as.vector(B))\n\n## Create correlation matrix ####\n\nHLM_AR1_corr <- function(id_fac, time, rho, phi) {\n  C.mat <- matrix(0,length(id_fac), length(id_fac))\n  for (i in levels(id_fac)) {\n    ind <- (id_fac == i)\n    C.mat[ind,ind] <- rho + (1 - rho) * phi^as.matrix(dist(time[ind]))\n  }\n  return(C.mat)\n}\n\n## Calculate lagged sums of squares ####\n\nauto_SS <- function(x, n = length(x)) {\n  if (n > 1) {\n    e <- x - mean(x)\n    auto_0 <- sum(e * e)\n    auto_1 <- sum(e[1:(n-1)] * e[2:n])\n  } else {\n    auto_0 <- NA\n    auto_1 <- NA\n  }\n  return(c(auto_0, auto_1))\n}\n\n## Hedges G correction ####\n\nJ <- function(x) 1 - 3 / (4 * x - 1)\n\n\n\n\n## calculate effect size (with associated estimates) for multiple baseline design ####\n\n#' @title Calculates HPS effect size\n#' \n#' @description Calculates the HPS effect size estimator based on data from a multiple baseline design, \n#' as described in Hedges, Pustejovsky, & Shadish (2013). Note that the data must contain one row per \n#' measurement occasion per subject.\n#' \n#' @param outcome Vector of outcome data. May not contain any missing values.\n#' @param treatment Vector of treatment indicators. Must be the same length as \\code{outcome}.\n#' @param id factor vector indicating unique cases. Must be the same length as \\code{outcome}.\n#' @param time vector of measurement occasion times. Must be the same length as \\code{outcome}.\n#' @param phi Optional value of the auto-correlation nuisance parameter, to be used \n#' in calculating the small-sample adjusted effect size\n#' @param rho Optional value of the intra-class correlation nuisance parameter, to be used \n#' in calculating the small-sample adjusted effect size\n#' \n#' @note If phi or rho is left unspecified (or both), estimates for the nuisance\n#' parameters will be calculated.\n#' \n#' @export \n#' \n#' @return A list with the following components\n#' \\tabular{ll}{\n#' \\code{g_dotdot} \\tab total number of non-missing observations \\cr\n#' \\code{K} \\tab number of time-by-treatment groups containing at least one observation \\cr\n#' \\code{D_bar} \\tab numerator of effect size estimate \\cr\n#' \\code{S_sq} \\tab sample variance, pooled across time points and treatment groups \\cr\n#' \\code{delta_hat_unadj} \\tab unadjusted effect size estimate \\cr\n#' \\code{phi} \\tab corrected estimate of first-order auto-correlation \\cr\n#' \\code{sigma_sq_w} \\tab corrected estimate of within-case variance \\cr\n#' \\code{rho} \\tab estimated intra-class correlation \\cr\n#' \\code{theta} \\tab estimated scalar constant \\cr\n#' \\code{nu} \\tab estimated degrees of freedom \\cr\n#' \\code{delta_hat} \\tab corrected effect size estimate \\cr\n#' \\code{V_delta_hat} \\tab estimated variance of \\code{delta_hat}\n#' }\n#' \n#' @references Hedges, L. V., Pustejovsky, J. E., & Shadish, W. R. (2013). \n#' A standardized mean difference effect size for multiple baseline designs. \n#' Working paper, Evanston, IL.\n#' \n#' @examples\n#' data(Saddler)\n#' with(subset(Saddler, measure==1), effect_size_MB(outcome, treatment, case, time))\n#' \n#' data(Laski)\n#' with(Laski, effect_size_MB(outcome, treatment, case, time))\n\neffect_size_MB <- function(outcome, treatment, id, time, phi, rho) {\n  \n  ###########\n  ## setup ##\n  ###########\n  \n  # create factor variables\n  treatment_fac <- factor(treatment)\n  id_fac <- factor(id)\n  time_fac <- factor(time)\n    \n  # unique times, unique cases, calculate sample sizes  \n  time_points <- seq(min(time), max(time),1)    # unique measurement occasions j = 1,...,N\n  N <- length(time_points)                      # number of unique measurement occasions\n  h_i_p <- table(id_fac, treatment_fac)         # number of non-missing observations for case i in phase p\n  cases <- levels(id_fac)                       # unique cases i = 1,...,m\n  m <- length(cases)                            # number of cases\n  g_dotdot <- length(outcome)                   # total number of non-missing observations\n  \n  \n  ######################################\n  ## calculate unadjusted effect size ##\n  ######################################\n  \n  # fixed effects regression with id-by-treatment interaction\n  case_FE <- lm(outcome ~ id_fac + id_fac:treatment_fac + 0)\n  X_case_FE <- model.matrix(case_FE)                            # design matrix from id-by-treatment fixed-effects regression\n  X_trt <- attr(X_case_FE, \"assign\") == 2                       # indicator for individual treatment effects\n  XtX_inv_case_FE <- solve(t(X_case_FE) %*% X_case_FE)          # inverse of (X'X) for this design matrix\n  \n  # calculate D-bar\n  D_bar <- mean(coef(case_FE)[X_trt])           # See p. 11, Eq. (2).\n  \n  # fixed effects regression with time-by-treatment interaction\n  time_FE <- lm(outcome ~ time_fac + time_fac:treatment_fac + 0)\n  X_time_FE <- model.matrix(time_FE)[,time_FE$qr$pivot[1:time_FE$qr$rank]]    # design matrix for time-by-treatment fixed-effects regression\n  \n  # calculate pooled variance S-squared\n  S_sq <- summary(time_FE)$sigma^2              # See p. 12, Eq. (3) and also footnote 5.\n  K <- time_FE$rank                             # number of time-by-treatment groups containing at least one observation. See p. 11.\n\n  # calculate unadjusted effect size\n  delta_hat_unadj <- D_bar / sqrt(S_sq)         # See p. 13, Eq. (4)\n  \n  \n  ##################################\n  ## nuisance parameter estimates ##\n  ##################################\n  \n  if (missing(phi) | missing(rho)) {\n    # auto-covariances - See first display equation on p. 32.\n    acv_SS <- matrix(unlist(tapply(case_FE$residuals[order(id_fac, time)], id_fac, auto_SS)), m, 2, byrow=TRUE)\n    \n    # calculate adjusted autocorrelation\n    if (missing(phi)) {\n      phi_YW <- sum(acv_SS[,2], na.rm=T) / sum(acv_SS[,1], na.rm=T)\n      phi_correction <- sum((h_i_p - 1) / h_i_p) / (g_dotdot - 2 * m)   # This is the constant C given on p. 33.\n      phi <- phi_YW + phi_correction                                # See last display equation on p. 32.      \n    }\n    \n    if (missing(rho)) {\n      # calculate adjusted within-case variance estimate\n      sigma_sq_correction <- g_dotdot - product_trace(XtX_inv_case_FE, t(X_case_FE) %*% HLM_AR1_corr(id_fac, time, 0, phi) %*% X_case_FE) \n      # This correction is equal to g_dotdot * F, where F is given on p. 33. \n      sigma_sq_w <- sum(acv_SS[,1], na.rm=T) / sigma_sq_correction\n      \n      # calculate intra-class correlation\n      rho <- max(0, 1 - sigma_sq_w / S_sq)                          # See last display equation on p. 33.    \n    } else sigma_sq_w <- NA\n  } else sigma_sq_w <- NA\n  \n  \n  ############################################\n  ## calculate degrees of freedom and theta ##\n  ############################################\n  \n  # create A matrix\n  A_mat <- diag(rep(1, g_dotdot)) - X_time_FE %*% solve(t(X_time_FE) %*% X_time_FE) %*% t(X_time_FE)  # S^2 = y'(A_mat)y / (g_dotdot - K). See p. 29. \n  \n  # create correlation matrix\n  V_mat <- HLM_AR1_corr(id_fac, time, rho, phi)    # V_mat is the matrix Sigma on p. 28, scaled by tau^2 + sigma^2. \n  \n  # calculate degrees of freedom\n  AV <- A_mat %*% V_mat\n  nu <- (g_dotdot - K)^2 / product_trace(AV, AV)          # See p. 15, Eq. (11). Also note that product_trace(AV, AV) = tr(A Sigma A Sigma). See p. 30.\n\n  # calculate theta\n  theta <- sqrt(sum(diag(XtX_inv_case_FE %*% t(X_case_FE) %*% V_mat %*% X_case_FE %*% XtX_inv_case_FE)[X_trt])) / m   # See p. 15, Eq. (10). \n  \n\n  #######################################\n  ## adjusted effect size and variance ##\n  #######################################\n  \n  # calculate adjusted effect size\n  delta_hat <- J(nu) * delta_hat_unadj    # See p. 15, Eq. (13). \n  \n  # calculate variance of adjusted effect size\n  V_delta_hat <- J(nu)^2 * (theta^2 * nu / (nu - 2) + delta_hat^2 * (nu / (nu - 2) - 1 / J(nu)^2))   # See p. 15, Eq. (14). \n  \n  \n  ####################\n  ## return results ##\n  ####################\n  \n  results <- list(g_dotdot = g_dotdot, K = K, D_bar = D_bar, S_sq = S_sq, delta_hat_unadj = delta_hat_unadj, \n               phi = phi, sigma_sq_w = sigma_sq_w, rho = rho, \n               theta = theta, nu = nu, delta_hat = delta_hat, V_delta_hat = V_delta_hat)\n  return(results)\n}\n\n\n\n## calculate effect size (with associated estimates) for (AB)^k design ####\n\n#' @title Calculates HPS effect size\n#' \n#' @description Calculates the HPS effect size estimator based on data from an (AB)^k design, \n#' as described in Hedges, Pustejovsky, & Shadish (2012). Note that the data must contain one row per \n#' measurement occasion per subject.\n#' \n#' @param outcome Vector of outcome data. May not contain any missing values.\n#' @param treatment Vector of treatment indicators. Must be the same length as \\code{outcome}.\n#' @param id factor vector indicating unique cases. Must be the same length as \\code{outcome}.\n#' @param phase factor vector indicating unique phases (each containing one contiguous control \n#' condition and one contiguous treatment condition). Must be the same length as \\code{outcome}.\n#' @param time vector of measurement occasion times. Must be the same length as \\code{outcome}.\n#' @param phi Optional value of the auto-correlation nuisance parameter, to be used \n#' in calculating the small-sample adjusted effect size\n#' @param rho Optional value of the intra-class correlation nuisance parameter, to be used \n#' in calculating the small-sample adjusted effect size\n#' \n#' @note If phi or rho is left unspecified (or both), estimates for the nuisance\n#' parameters will be calculated.\n#' \n#' @export \n#' \n#' @return A list with the following components\n#' \\tabular{ll}{\n#' \\code{M_a} \\tab Matrix reporting the total number of time points with data for all ids, \n#' by phase and treatment condition \\cr\n#' \\code{M_dot} \\tab Total number of time points used to calculate the total variance (the sum of \\code{M_a}) \\cr\n#' \\code{D_bar} \\tab numerator of effect size estimate \\cr\n#' \\code{S_sq} \\tab sample variance, pooled across time points and treatment groups \\cr\n#' \\code{delta_hat_unadj} \\tab unadjusted effect size estimate \\cr\n#' \\code{phi} \\tab corrected estimate of first-order auto-correlation \\cr\n#' \\code{sigma_sq_w} \\tab corrected estimate of within-case variance \\cr\n#' \\code{rho} \\tab estimated intra-class correlation \\cr\n#' \\code{theta} \\tab estimated scalar constant \\cr\n#' \\code{nu} \\tab estimated degrees of freedom \\cr\n#' \\code{delta_hat} \\tab corrected effect size estimate \\cr\n#' \\code{V_delta_hat} \\tab estimated variance of the effect size\n#' }\n#' \n#' @references Hedges, L. V., Pustejovsky, J. E., & Shadish, W. R. (2012).\n#'  A standardized mean difference effect size for single case designs. \n#'  Research Synthesis Methods, 3, 224-239. doi:10.1002/jrsm.1052\n#' \n#' @examples\n#' data(Lambert)\n#' with(Lambert, effect_size_ABk(outcome, treatment, case, phase, time))\n#'    \n#' data(Anglesea)\n#' with(Anglesea, effect_size_ABk(outcome, treatment, case, phase, session))\n\n\neffect_size_ABk <- function(outcome, treatment, id, phase, time, phi, rho) {\n  \n  ###########\n  ## setup ##\n  ###########\n  \n  # create factor variables\n  treatment_fac <- factor(treatment)\n  id_fac <- factor(id)\n  phase_fac <- factor(phase)\n  \n  # number of cases\n  m <- nlevels(id_fac)                            \n  \n  # re-number time points per HPS (2012)\n  phase_point <- unlist(tapply(outcome, list(treatment, phase, id), \n                  function(x) 1:length(x)))\n  phase_point_fac <- ordered(phase_point)\n    \n  # determine M^a values. See p. 231, formulas (16-17)\n  M_a <- apply(tapply(outcome, \n                list(phase_point, treatment_fac, phase_fac), \n                function(x) length(x) == m), \n               c(2,3), sum, na.rm = TRUE)\n  M_dot <- sum(M_a, na.rm = TRUE)  \n  \n  include <- mapply(function(phase, treat, point) \n    m == sum(phase==phase_fac & treat==treatment_fac & point==phase_point), \n                       phase_fac, treatment_fac, phase_point)\n  \n  ######################################\n  ## calculate unadjusted effect size ##\n  ######################################\n  \n  if (nlevels(phase_fac) > 1) {\n    # fixed effects regression with id-by-phase-by-treatment interaction\n    case_FE <- lm(outcome ~ id_fac:phase_fac + id_fac:phase_fac:C(treatment_fac, treatment) + 0)\n    # fixed effects regression with phase-point-by-treatment-by-phase interaction\n    time_FE <- lm(outcome ~ phase_point_fac:treatment_fac:phase_fac + 0,\n                  data = data.frame(outcome, phase_point_fac, treatment_fac, phase_fac),\n                  subset = include)    \n  } else {\n    # fixed effects regression with id-by-phase-by-treatment interaction\n    case_FE <- lm(outcome ~ id_fac + id_fac:C(treatment_fac, treatment) + 0)\n    # fixed effects regression with phase-point-by-treatment-by-phase interaction\n    time_FE <- lm(outcome ~ phase_point_fac:treatment_fac + 0,\n                  data = data.frame(outcome, phase_point_fac, treatment_fac, phase_fac),\n                  subset = include)    \n    \n  }\n  \n  # design matrix from id-by-phase-by-treatment fixed-effects regression\n  X_case_FE <- model.matrix(case_FE)  \n  X_trt <- attr(X_case_FE, \"assign\") == 2                       # indicator for individual treatment effects\n  XtX_inv_case_FE <- solve(t(X_case_FE) %*% X_case_FE)          # inverse of (X'X) for this design matrix\n  \n  # calculate D-bar\n  D_bar <- mean(coef(case_FE)[X_trt])           # See p. 231, formula (19).\n  \n  # design matrix for phase-point-by-treatment-by-phase fixed-effects regression\n  X_time_FE <- model.matrix(time_FE)[,time_FE$qr$pivot[1:time_FE$qr$rank]]    \n  \n  # calculate pooled variance S-squared\n  S_sq <- summary(time_FE)$sigma^2              # See p. 231, formula (18).\n  \n  # calculate unadjusted effect size\n  delta_hat_unadj <- D_bar / sqrt(S_sq)         # See p. 231, formula (20).\n  \n  \n  ##################################\n  ## nuisance parameter estimates ##\n  ##################################\n  \n  if (missing(phi) | missing(rho)) {\n    # auto-covariances - See first display equation on p. 32.\n    YW <- aggregate(outcome, by = list(id_fac, phase_fac, treatment_fac), \n                    function(x) c(auto_SS(x), length(x))) # calculate auto-covariances by case by phase\n    YW <- cbind(YW[,1:3], YW$x)\n    names(YW) <- c(\"id_fac\",\"phase_fac\",\"treatment_fac\",\"g0\",\"g1\",\"n\")\n\n    # calculate adjusted estimate of pooled auto-correlation. See p. 238.\n    if (missing(phi)) phi <- sum(YW$g1, na.rm=T) / sum(YW$g0, na.rm=T) + sum(1 - 1 / YW$n) / sum(YW$n - 1)\n    \n    if (missing(rho)) {\n      # calculate adjusted within-case variance estimate\n      sigma_sq_correction <- length(outcome) - product_trace(XtX_inv_case_FE, t(X_case_FE) %*% HLM_AR1_corr(id_fac, phase_point, 0, phi) %*% X_case_FE) \n      sigma_sq_w <- sum(YW$g0, na.rm=T) / sigma_sq_correction\n      \n      rho <- max(0, 1 - sigma_sq_w / S_sq)      # See last display equation on p. 238.\n    } else sigma_sq_w <- NA\n  } else sigma_sq_w <- NA\n  \n  \n  ############################################\n  ## calculate degrees of freedom and theta ##\n  ############################################\n  \n  # create A matrix. S^2 = y'(A_mat)y / (M_dot * (m - 1)). See p. 236. \n  A_mat <- diag(rep(1, dim(X_time_FE)[1])) - X_time_FE %*% solve(t(X_time_FE) %*% X_time_FE) %*% t(X_time_FE)  \n  \n  # V_mat is the matrix Sigma_T on p. 236, scaled by tau^2 + sigma^2. \n  V_mat <- HLM_AR1_corr(id_fac, time, rho, phi)    \n  \n  # calculate degrees of freedom. See p. 232, formula (28). \n  AV <- A_mat %*% V_mat[include, include]\n  nu <- (M_dot * (m - 1))^2 / product_trace(AV, AV)\n  \n  # calculate theta. See p. 232, formula (27).\n  theta <- sqrt(sum((XtX_inv_case_FE %*% t(X_case_FE) %*% \n              V_mat %*% X_case_FE %*% XtX_inv_case_FE)[X_trt, X_trt])) / sum(X_trt)\n  \n  \n  #######################################\n  ## adjusted effect size and variance ##\n  #######################################\n  \n  # calculate adjusted effect size. See p. 232, formula (29).\n  delta_hat <- J(nu) * delta_hat_unadj    # See p. 15, Eq. (13). \n  \n  # calculate variance of adjusted effect size. See p. 232, formula (30).\n  V_delta_hat <- J(nu)^2 * (theta^2 * nu / (nu - 2) + delta_hat^2 * (nu / (nu - 2) - 1 / J(nu)^2))   # See p. 15, Eq. (14). \n  \n  \n  ####################\n  ## return results ##\n  ####################\n  \n  results <- list(M_a = M_a, M_dot = M_dot,\n                  D_bar = D_bar, S_sq = S_sq, delta_hat_unadj = delta_hat_unadj, \n                  phi = phi, sigma_sq_w = sigma_sq_w, rho = rho, \n                  theta = theta, nu = nu, \n                  delta_hat = delta_hat, V_delta_hat = V_delta_hat)\n  return(results)\n}\n",
    "created" : 1370621511787.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2606363093",
    "id" : "B93CB723",
    "lastKnownWriteTime" : 1370631602,
    "path" : "C:/Users/James/Dropbox/Single-subject designs/scdhlm/R/HPS-ES-functions.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}